# 1. 线程Thread源码探析
## 1.1.  线程的初始化
> 入口方法: `init(g, target, name, stackSize, null, true);`

  - 1.创建本线程的线程，即作为该线程的父线程
  - 2.每个线程都会有一个线程组(ThreadGroup),若没有指定，则线程组就是父线程的线程组
  - 3.当前线程的daemon默认为父线程的daemon状态
  - 4.线程优先级默认是父线程的优先级
  - 5.线程id是全局递增，从1开始。
## 1.2. 线程的启动
> 入口方法 `public synchronized void start() `
```java
  public synchronized void start() {
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
        group.add(this);
        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
            }
        }
  }
```

 - 1.`threadStatus`默认为0，线程一旦执行过之后，就会变为非0的状态，此时现在不能再次被start();
 - 2.你启动线程之后，这个线程就会加入之前处理好的那个线程组中
 - 3.启动一个线程实际上走的是native方法，start0()，会实际的启动一个线程
 - 4.一个线程启动之后就会执行run()方法

## 1.3.Daemon(后台线程)
> 又称为守护线程，当工作线程都停止的话，那么`Daemon`会跟着jvm进程一起推出；

## 1.4.interrupt
> 在一个线程中调用另一个线程的interrupt()方法，即会向那个线程发出信号——线程中断状态已被设置。至于那个线程何去何从，由具体的代码实现决定。

```java
public class InterruptDemo {

  public static void main(String[] args) throws InterruptedException {
    MyThread t1 = new MyThread();
    t1.start();
    Thread.sleep(1000);
    t1.setShouldRun(false);
    t1.interrupt();
    System.out.println(">>>>>>>>>>>>>>>>>>>>>"+t1.isInterrupted());
  }

  private static class MyThread extends Thread{
    private boolean shouldRun = true;

    @Override
    public void run() {
      while (shouldRun){
        try {
          System.out.println(Thread.currentThread().getName()+"正在工作......");
          Thread.sleep(30*1000);
        }catch (Exception e){
          e.printStackTrace();
        }
      }
    }

    public void setShouldRun(boolean shouldRun){
      this.shouldRun = shouldRun;
    }
  }
}
```
主要应用与中断其他线程的休眠，和sleep结合，用于标志位的处理。
