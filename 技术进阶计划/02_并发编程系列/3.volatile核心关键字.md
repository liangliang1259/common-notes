## 1.并发编程的核心特性
> 可见性，原子性，有序性

 - 可见性：之前博客中的内容都是可见性的描述，即文章中内容都是可见性的说明
 - 原子性: 即一个操作或者多个操作当成一个原子，要么成功，要么失败。
 - 有序性：系统有时为了提高代码的运行效率，会对编译后的代码指令进行重排序。因此在多线程环境下有可能会导致代码异常。
## 2.volatile关键字

### 2.1.如何保证系统的可见性
![](https://tva1.sinaimg.cn/large/0081Kckwly1gm87n7559qj311s0nm75z.jpg)
[源文件](https://processon.com/diagraming/5feebf75f346fb432bd06eb8)

基于上篇的文章进行分析。如果上篇中flag加了`volatile`关键字。那么此时的情形就会变成下面这样。
 - 1.线程1将flag=0变为flag=1,之后需要执行assign操作，如果加了`volatile`关键字，那么就会保证执行完了assign之后会立马执行store+write操作了。立马刷回主内存
 - 2.然后会让线程2对应工作内存中的flag=0立马失效，此时需要从主内存中渠道读取数据flag=1.

### 2.2.如何为何无法保障系统的原子性
两个线程可能会先后写入数据。假如线程1
![](https://tva1.sinaimg.cn/large/0081Kckwly1gmbwbq2rtwj30jl0c73z0.jpg)
[源文件](https://processon.com/diagraming/5ff2f571e0b34d19e4181349)
 - 线程1和线程2分别将i=1读入自己的工作内存
 - 线程1将进行++操作，此时使用的是工作内存中的数据，
 - 线程2将进行++操作，此时使用的是工作内存中的数据
 - 线程1处理完成之后，写入工作内存i=2,之后更新到主内存，并使工作内存2中的i=1失效
 - 线程2已经使用了i=1,并修改为2，此时同样写会主内存，i=2
### 2.3.如何保障系统的有序性
> happens before原则
禁止指令重排序，内存屏障实现。
#### 1.lock指令
> lock前缀指令+MESI缓存一致性协议实现。

对于volatile修饰的变量，如果执行写操作的话，jvm会发送一条lock前缀指令给cpu，cpu在计算完成之后立即将该值写回主内存，依赖MESI缓存一致性协议，其他cpu会进行嗅探，若本地缓存数据被更新则过期该数据，重新加载
#### 2.内存屏障，禁止指令重排序
```java
Load1：
int localVar = this.variable
Load2：
int localVar = this.variable2
```
LoadLoad屏障：Load1；LoadLoad；Load2，确保Load1数据的装载先于Load2后所有装载指令，他的意思，Load1对应的代码和Load2对应的代码，是不能指令重排的




## 3.关于
 - Github: [https://github.com/liangliang1259/common-notes](https://github.com/liangliang1259/common-notes)
 - 公众号
![](https://tva1.sinaimg.cn/large/007S8ZIlly1giznpxhgdvj3076076gm3.jpg)